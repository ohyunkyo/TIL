{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/django-rest-framework/serialize-many-to-many-relationships/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Today I Learned"}},"markdownRemark":{"id":"7d78947b-1b02-540f-9a67-faa8528ff575","excerpt":"0. 서론 기본적으로  를 가진 모델(Package)을 직렬화할 경우 연관된 모델(Product)의 pk 만을 가지고 오게 된다. 기본 serializer 가 반환하는 데이터 before-customize 나는 Package 를 직렬화 할때 Product 의 pk…","html":"<h2>0. 서론</h2>\n<p>기본적으로 <code class=\"language-text\">manytomanyfield</code> 를 가진 모델(Package)을 직렬화할 경우 연관된 모델(Product)의 pk 만을 가지고 오게 된다.</p>\n<p>기본 serializer 가 반환하는 데이터<br>\n<img src=\"/TIL/images/serialize-many-to-many-relationships/before-customize.png\" alt=\"before-customize\"></p>\n<p>나는 Package 를 직렬화 할때 Product 의 pk 이외에 다른 컬럼을 가져와야 했다.<br>\n그리고 package_product 테이블에 생성한 custom field 인 quantity 도 가져와야 했기 때문에 <code class=\"language-text\">serializer</code> 를 커스터마이징 할 필요가 있었다.</p>\n<p>내가 원하는 데이터\r\n<img src=\"/TIL/images/serialize-many-to-many-relationships/after-customize.png\" alt=\"after-customize\"></p>\n<h2>1. 새로운 serializer 생성하기</h2>\n<p>기존에 사용하던 serializer 는 <code class=\"language-text\">create()</code>, <code class=\"language-text\">list()</code>, <code class=\"language-text\">update()</code>, <code class=\"language-text\">delete()</code> 에서 계속 사용하고 <code class=\"language-text\">package detail</code> 을 위해 하나 더 만들기로 했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># serializer.py\r\n\r\nclass PackageDetailSerializer(serializers.ModelSerializer):\r\n    is_split = serializers.SerializerMethodField()\r\n    business_id = serializers.ReadOnlyField(source='business.id')\r\n    business_name = serializers.ReadOnlyField(source='business.name')\r\n    package_product_list = PackageProductSerializer(source='packageproduct_set', many=True)\r\n    package_supplement_list = PackageSupplementSerializer(source='packagesupplement_set', many=True)\r\n    \r\n    class Meta:\r\n        model = Package\r\n        fields = ['id', 'name', 'description', 'serial_code', 'product_code', 'memo', 'is_split', 'business_id', 'business_name', 'package_product_list', 'package_supplement_list']\r\n    \r\n    def get_is_split(self, obj):\r\n        if obj.is_split:\r\n            return '분할함'\r\n        else:\r\n            return '분할하지 않음'</code></pre></div>\n<p>serializer 의 field 를 생성할 때 다른 serializer 를 사용했다.<br>\n<code class=\"language-text\">PackageProductSerializer</code> 를 내가 원하는 데이터를 리턴하도록 만들었기 때문에 <code class=\"language-text\">PackageDetailSerializer</code> 에서도 동일하게 원하는 데이터를 확인할 수 있게 되었다.<br>\n<a href=\"https://hyun-am-coding.tistory.com/entry/9-1-Serializers\">출처1</a>\r\n<a href=\"https://www.django-rest-framework.org/api-guide/serializers/#dealing-with-nested-objects\">출처2</a></p>\n<p><code class=\"language-text\">source</code> 인수는 필드를 채우는데 사용할 속성의 이름이라고 한다. 이 인수를 사용하지 않으면 필드이름과 동일한 데이터를 찾게된다.<br>\n예를들어 business_name 필드를 만들때 <code class=\"language-text\">source='business.name'</code> 이라고 지정해주지 않았다면 Package 모델에서 business_name 이라는 필드를 찾게 된다는 말이다.\r\n<a href=\"https://www.django-rest-framework.org/api-guide/fields/#source\">출처</a></p>\n<p><code class=\"language-text\">_set</code> 은 Package 모델에서 자신을 foreign key 로 가지고 있는 모델인 PackageProduct 에 접근하기 위한 방법이다.\r\n<a href=\"https://freeprog.tistory.com/55\">출처</a></p>\n<p><code class=\"language-text\">many=True</code> 플래그는 단순한 데이터가 아닌 리스트를 반환해야 할 경우 사용한다.</p>\n<p><a href=\"https://stackoverflow.com/questions/41976819/django-serialize-a-model-with-a-many-to-many-relationship-with-a-through-argume/41996831#41996831\">처음본 곳</a></p>\n<h2>2. ViewSet 에서 serializer 분리하기</h2>\n<p>위에서 생성한 serializer 를 <code class=\"language-text\">detail()</code> 메서드에서만 사용해야 했기때문에 메서드 별로 다른 serializer 를 사용하는 방법을 찾아봤다.</p>\n<p><code class=\"language-text\">ModelViewSet</code> 을 상속받는 ViewSet 의 경우 <code class=\"language-text\">serializer_class</code> 속성으로 직렬화에 사용할 클래스를 지정할 수 있다.<br>\n만약 하나의 ViewSet 에서 메서드마다 사용할 직렬화 클래스를 다르게 설정하고 싶다면 다음과 같이 하면 된다</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># views.py</span>\r\n\r\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">PackageModelViewSet</span><span class=\"token punctuation\">(</span>ModelViewSet<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n    queryset <span class=\"token operator\">=</span> Package<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\r\n    filter_backends <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>DjangoFilterBackend<span class=\"token punctuation\">]</span>\r\n    filterset_class <span class=\"token operator\">=</span> PackageFilter\r\n    \r\n    <span class=\"token keyword\">def</span> <span class=\"token function\">get_serializer_class</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n        <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>action <span class=\"token operator\">==</span> <span class=\"token string\">'retrieve'</span><span class=\"token punctuation\">:</span>\r\n            <span class=\"token keyword\">return</span> PackageDetailSerializer\r\n    \r\n        <span class=\"token keyword\">return</span> PackageSerializer</code></pre></div>\n<p><code class=\"language-text\">serializer_class</code> 속성을 그대로 사용하고 싶었지만 <code class=\"language-text\">get_serializer_class</code> 메서드를 오버라이딩 하면 적용되지 않는듯 했다.</p>\n<p><a href=\"https://stackoverflow.com/questions/22616973/django-rest-framework-use-different-serializers-in-the-same-modelviewset\">출처</a></p>\n<h2>99. 끝나고 나서</h2>\n<p>package_product_list 와 package_supplement_list 의 데이터중 <code class=\"language-text\">package detail</code> 컴포넌트에서 사용하지 않는 데이터가 많다.<br>\n성능 이슈가 발생할 가능성이 있기때문에 이중에서 필요한 데이터만 가져오는 방법을 찾아야할것같다.</p>","frontmatter":{"title":"다대다 관계 모델 직렬화(serialize) 하기","date":"March 31, 2022","description":null},"fields":{"category":"django-rest-framework","slug":"/django-rest-framework/serialize-many-to-many-relationships/"}},"previous":{"fields":{"slug":"/vue-js/pass-data-to-modal/"},"frontmatter":{"title":"모달에 데이터 전달하기"}},"next":{"fields":{"slug":"/django-rest-framework/get-another-models-data-which-has-same-foreign-key/"},"frontmatter":{"title":"foreign key 가 동일한 다른 모델의 데이터 가져오기"}}},"pageContext":{"id":"7d78947b-1b02-540f-9a67-faa8528ff575","previousPostId":"edc231b4-a8b4-5f98-a671-02c9056dce56","nextPostId":"10416c56-182a-55b5-8c24-74032c67dd68"}},
    "staticQueryHashes": ["230163734","2841359383","3496359572"]}